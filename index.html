<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rebalancing App</title>
    <script src="https://cdn.jsdelivr.net/pyodide/v0.24.1/full/pyodide.js"></script>
    <style>
        body { font-family: -apple-system, sans-serif; max-width: 800px; margin: 50px auto; padding: 20px; line-height: 1.6; }
        .container { border: 1px solid #ddd; padding: 20px; border-radius: 10px; box-shadow: 0 4px 6px rgba(0,0,0,0.1); }
        .input-row { display: grid; grid-template-columns: 2fr 1fr 1fr 1fr 2fr 2fr auto; gap: 10px; align-items: center; margin-bottom: 10px; }
        .input-row input { padding: 8px; border: 1px solid #ccc; border-radius: 4px; }
        .input-row .display-value { padding: 8px; background: #e9ecef; border: 1px solid #ced4da; border-radius: 4px; text-align: right; }
        .input-row button { padding: 8px 12px; background: #dc3545; color: white; border: none; border-radius: 4px; cursor: pointer; }
        .add-btn { padding: 10px 20px; background: #28a745; color: white; border: none; border-radius: 4px; cursor: pointer; margin-top: 10px; }
        .add-btn:hover { background: #218838; }
        .compute-contributions-btn { padding: 10px 20px; background: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer; margin-top: 10px; margin-left: 10px; }
        .compute-contributions-btn:hover { background: #0056b3; }
        .compute-contributions-btn:disabled { background: #6c757d; cursor: not-allowed; }
        .rebalance-btn { padding: 10px 20px; background: #6f42c1; color: white; border: none; border-radius: 4px; cursor: pointer; margin-top: 10px; margin-left: 10px; }
        .rebalance-btn:hover { background: #5a32a3; }
        .header-row { display: grid; grid-template-columns: 2fr 1fr 1fr 1fr 2fr 2fr auto; gap: 10px; font-weight: bold; margin-bottom: 15px; padding-bottom: 10px; border-bottom: 2px solid #007bff; }
        #holdings-list { margin-top: 20px; }
        .contribution-section { margin-bottom: 30px; padding: 15px; background: #f8f9fa; border-radius: 5px; }
        .contribution-section label { display: block; margin-bottom: 5px; font-weight: bold; }
        .contribution-section input { padding: 10px; width: 200px; border: 1px solid #ccc; border-radius: 4px; font-size: 16px; }
        .totals-row { display: grid; grid-template-columns: 2fr 1fr 1fr 1fr 2fr 2fr auto; gap: 10px; align-items: center; margin-top: 15px; padding-top: 15px; border-top: 2px solid #007bff; font-weight: bold; }
        .totals-row .display-value { padding: 8px; background: #d1ecf1; border: 1px solid #bee5eb; border-radius: 4px; text-align: right; }
        .import-btn { padding: 10px 20px; background: #17a2b8; color: white; border: none; border-radius: 4px; cursor: pointer; margin-top: 10px; margin-left: 10px; }
        .import-btn:hover { background: #138496; }
        .modal { display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.4); }
        .modal-content { background-color: #fefefe; margin: 5% auto; padding: 20px; border: 1px solid #888; border-radius: 10px; width: 90%; max-width: 700px; box-shadow: 0 4px 6px rgba(0,0,0,0.2); }
        .close { color: #aaa; float: right; font-size: 28px; font-weight: bold; cursor: pointer; }
        .close:hover, .close:focus { color: #000; }
        .modal textarea { width: 100%; height: 200px; padding: 10px; border: 1px solid #ccc; border-radius: 4px; font-family: monospace; font-size: 12px; margin-bottom: 15px; }
        .parse-btn { padding: 10px 20px; background: #28a745; color: white; border: none; border-radius: 4px; cursor: pointer; margin-right: 10px; }
        .parse-btn:hover { background: #218838; }
        .apply-btn { padding: 10px 20px; background: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer; }
        .apply-btn:hover { background: #0056b3; }
        .apply-btn:disabled { background: #6c757d; cursor: not-allowed; }
        .parsed-results { margin-top: 20px; padding: 15px; background: #f8f9fa; border-radius: 5px; max-height: 300px; overflow-y: auto; }
        .parsed-results table { width: 100%; border-collapse: collapse; }
        .parsed-results th, .parsed-results td { padding: 8px; text-align: left; border-bottom: 1px solid #ddd; }
        .parsed-results th { background: #007bff; color: white; font-weight: bold; }
        .parsed-results td:last-child { text-align: right; }
    </style>
</head>
<body>

<div class="container">
    <h2>Portfolio Rebalancing Calculator</h2>
    
    <div class="contribution-section">
        <label for="contribution-amount">Contribution Amount ($):</label>
        <input type="number" id="contribution-amount" placeholder="0.00" min="0" step="0.01">
    </div>
    
    <p>Enter your holdings to calculate rebalancing targets:</p>
    
    <div id="holdings-list">
        <div class="header-row">
            <div>Ticker</div>
            <div>Target %</div>
            <div>Current %</div>
            <div>Diff %</div>
            <div>Current Amount ($)</div>
            <div>Amount to Contribute ($)</div>
            <div></div>
        </div>
    </div>
    
    <button class="add-btn" id="add-row-btn">+ Add Holding</button>
    <button class="import-btn" id="import-btn">Import Holdings</button>
    
    <div class="totals-row">
        <div>TOTALS</div>
        <div class="display-value" id="total-target">0.00</div>
        <div class="display-value" id="total-current-percent">0.00</div>
        <div class="display-value" id="total-diff-percent">0.00</div>
        <div class="display-value" id="total-amount">0.00</div>
        <div class="display-value" id="total-contribute">0.00</div>
        <div></div>
    </div>
    
    <button class="compute-contributions-btn" id="compute-contributions-btn">Compute contributions</button>
    <button class="rebalance-btn" id="rebalance-btn">Rebalance</button>
</div>

<!-- Import Holdings Modal -->
<div id="import-modal" class="modal">
    <div class="modal-content">
        <span class="close">&times;</span>
        <h3>Import Holdings</h3>
        <p>Paste your holdings data below:</p>
        <textarea id="holdings-text" placeholder="Paste your holdings data here..."></textarea>
        <button class="parse-btn" id="parse-btn">Parse Data</button>
        
        <div id="parsed-results" class="parsed-results" style="display: none;">
            <h4>Parsed Holdings:</h4>
            <table id="parsed-table">
                <thead>
                    <tr>
                        <th>Ticker</th>
                        <th>Current Position ($)</th>
                    </tr>
                </thead>
                <tbody id="parsed-tbody"></tbody>
            </table>
            <div style="margin-top: 15px;">
                <button class="apply-btn" id="apply-btn">Apply to Current Amounts</button>
            </div>
        </div>
    </div>
</div>

<script>
    let holdingsData = [];
    let rowCounter = 0;
    let pyodide = null;
    let parsedHoldingsData = {};

    function addRow() {
        const rowId = rowCounter++;
        const rowDiv = document.createElement('div');
        rowDiv.className = 'input-row';
        rowDiv.id = `row-${rowId}`;
        
        rowDiv.innerHTML = `
            <input type="text" placeholder="e.g., VTSAX" data-field="ticker" data-row="${rowId}">
            <input type="number" placeholder="20" min="0" max="100" step="0.01" data-field="target" data-row="${rowId}">
            <div class="display-value" id="current-percent-${rowId}">0.00</div>
            <div class="display-value" id="diff-percent-${rowId}">0.00</div>
            <input type="number" placeholder="5000" min="0" step="0.01" data-field="amount" data-row="${rowId}">
            <div class="display-value" id="calc-${rowId}">0.00</div>
            <button onclick="removeRow(${rowId})">Remove</button>
        `;
        
        document.getElementById('holdings-list').appendChild(rowDiv);
        
        holdingsData.push({
            id: rowId,
            ticker: '',
            target: 0,
            amount: 0
        });
    }

    function removeRow(rowId) {
        const rowElement = document.getElementById(`row-${rowId}`);
        if (rowElement) {
            rowElement.remove();
        }
        holdingsData = holdingsData.filter(item => item.id !== rowId);
        updateTotals();
    }

    function updateTotals() {
        let totalTarget = 0;
        let totalAmount = 0;
        let totalContribute = 0;
        let totalDiffPercent = 0;
        
        holdingsData.forEach(holding => {
            totalTarget += holding.target || 0;
            totalAmount += holding.amount || 0;
            // Get the calculated contribution value from the display element
            const calcElement = document.getElementById(`calc-${holding.id}`);
            if (calcElement) {
                totalContribute += parseFloat(calcElement.textContent) || 0;
            }
        });
        
        // Update current percentages and differences for each holding
        holdingsData.forEach(holding => {
            const currentPercent = totalAmount > 0 ? ((holding.amount || 0) / totalAmount * 100) : 0;
            const currentPercentElement = document.getElementById(`current-percent-${holding.id}`);
            if (currentPercentElement) {
                currentPercentElement.textContent = currentPercent.toFixed(2);
            }
            
            const diffPercent = currentPercent - (holding.target || 0);
            const diffPercentElement = document.getElementById(`diff-percent-${holding.id}`);
            if (diffPercentElement) {
                diffPercentElement.textContent = diffPercent.toFixed(2);
            }
            totalDiffPercent += Math.abs(diffPercent);
        });
        
        document.getElementById('total-target').textContent = totalTarget.toFixed(2);
        document.getElementById('total-current-percent').textContent = totalAmount > 0 ? '100.00' : '0.00';
        document.getElementById('total-diff-percent').textContent = totalDiffPercent.toFixed(2);
        document.getElementById('total-amount').textContent = totalAmount.toFixed(2);
        document.getElementById('total-contribute').textContent = totalContribute.toFixed(2);
    }

    document.getElementById('add-row-btn').addEventListener('click', addRow);

    // Add event listener to update holdings data when inputs change
    document.getElementById('holdings-list').addEventListener('input', (e) => {
        if (e.target.tagName === 'INPUT') {
            const rowId = parseInt(e.target.dataset.row);
            const field = e.target.dataset.field;
            const value = e.target.value;
            
            const holding = holdingsData.find(h => h.id === rowId);
            if (holding) {
                holding[field] = field === 'ticker' ? value : parseFloat(value) || 0;
                updateTotals();
            }
        }
    });

    async function initPyodide() {
        pyodide = await loadPyodide();
        await pyodide.loadPackage('numpy');
        await pyodide.loadPackage('scipy');
        console.log("Python is ready!");
        document.getElementById('compute-contributions-btn').disabled = false;
    }

    async function computeContributions() {
        if (!pyodide) {
            console.error('Pyodide not initialized yet');
            return;
        }
        
        // Validate that target percentages sum to 100
        const totalTargetPercent = holdingsData.reduce((sum, holding) => sum + (holding.target || 0), 0);
        if (Math.abs(totalTargetPercent - 100) > 0.01) {
            alert(`Target percentages must sum to 100%. Current sum is ${totalTargetPercent.toFixed(2)}%`);
            return;
        }
        
        // Get contribution amount
        const contributionAmount = parseFloat(document.getElementById('contribution-amount').value) || 0;
        
        // Create list of dictionaries with all holding data
        const holdingsList = holdingsData.map(h => ({
            ticker: h.ticker || '',
            target_percent: h.target || 0,
            current_amount: h.amount || 0
        }));
        
        // Pass data to Python namespace
        pyodide.globals.set('contribution_amount', contributionAmount);
        pyodide.globals.set('holdings_list', holdingsList);
        
        const pythonCode = `
import numpy as np
from scipy.optimize import minimize
from dataclasses import dataclass
from typing import List

@dataclass
class Holding:
    ticker: str
    target_percentage: float
    current_holding: float

@dataclass
class Contribution:
    ticker: str
    amount_to_deposit: float

def objective(c: np.ndarray, x: np.ndarray, p: np.ndarray, T: float) -> float:
    # objective is sum of the abs diff between the projected percentage and the target percentage
    denom = (x + c * T).sum()

    j_c = np.sum(np.abs(((x + c * T) / denom) - p))

    return j_c

def new_objective(c: np.ndarray, x: np.ndarray, p: np.ndarray, T: float, debug: bool) -> float:
    projected_value_per_fund = x + c * T
    total_projected_portfolio_value = (projected_value_per_fund).sum()

    diff_between_projected_and_target = (projected_value_per_fund / total_projected_portfolio_value) - p

    underfunded_diffs = diff_between_projected_and_target[diff_between_projected_and_target <= 0]
    overfunded_diffs = diff_between_projected_and_target[diff_between_projected_and_target > 0]

    if debug:
        print("c", c)
        print("diffs", diff_between_projected_and_target)
        print("underfunded diffs", underfunded_diffs)
        print("")

    diff_between_min_and_max_underfunded = np.abs(underfunded_diffs.max() - underfunded_diffs.min())
    overfunded_penalty = np.sum(overfunded_diffs * 10)

    j_c = diff_between_min_and_max_underfunded + overfunded_penalty

    return j_c

def sum_to_1_constraint(c: np.ndarray):
    return 1.0 - c.sum()

def get_optimal_values_new(holdings: List[Holding], amount_to_deposit, debug=False) -> List[Contribution]:
    num_holdings = len(holdings)
    c_0 = np.ones(num_holdings) * (1.0 / num_holdings)

    current_values = np.array([h.current_holding for h in holdings])
    target_fractions = np.array([h.target_percentage for h in holdings]) * 1e-2

    bounds = [[0.0, 1.0] for _ in range(num_holdings)]
    constraint_params = {"type": "eq", "fun": sum_to_1_constraint}
    constraints = [constraint_params]

    solution = minimize(new_objective, c_0, args=(current_values, target_fractions, amount_to_deposit, debug), method="SLSQP", bounds=bounds, constraints=constraints)

    rounded_values = np.round(amount_to_deposit * solution.x, 2)
    if rounded_values.sum() > amount_to_deposit:
        rounded_values[0] = rounded_values[0] - (rounded_values.sum() - amount_to_deposit)
    elif rounded_values.sum() < amount_to_deposit:
        rounded_values[0] = rounded_values[0] + (amount_to_deposit - rounded_values.sum())

    return [
        Contribution(ticker=h.ticker, amount_to_deposit=float(r))
        for h, r in zip(holdings, rounded_values)
    ]

def main() -> List[Contribution]:
    # Convert JavaScript proxy to Python object
    holdings_py = holdings_list.to_py()

    holdings = [
        Holding(ticker=h['ticker'], target_percentage=h['target_percent'], current_holding=h['current_amount']) 
        for h in holdings_py
    ]

    return get_optimal_values_new(holdings, contribution_amount, debug=False)


if __name__ == "__main__":
    contributions = main()

    contributions_dicts = [{'ticker': c.ticker, 'amount_to_deposit': c.amount_to_deposit} for c in contributions]

contributions_dicts
        `;
        
        try {
            const result = await pyodide.runPythonAsync(pythonCode);
            console.log('Python result:', result);
            
            // Convert Python result to JavaScript array
            const contributions = result.toJs();
            console.log('Contributions JS:', contributions);
            
            // Update each holding's display value
            contributions.forEach(contrib => {
                const ticker = contrib.get('ticker');
                const amountToDeposit = contrib.get('amount_to_deposit');
                
                // Find the corresponding holding by ticker
                const holding = holdingsData.find(h => h.ticker === ticker);
                if (holding) {
                    // Update the display element
                    const displayElement = document.getElementById(`calc-${holding.id}`);
                    if (displayElement) {
                        displayElement.textContent = amountToDeposit.toFixed(2);
                    }
                }
            });
            
            // Update totals after updating all contributions
            updateTotals();
            
        } catch (err) {
            console.error('Python error:', err);
        }
    }

    document.getElementById('compute-contributions-btn').addEventListener('click', computeContributions);
    document.getElementById('compute-contributions-btn').disabled = true;

    function rebalance() {
        // Validate that target percentages sum to 100
        const totalTargetPercent = holdingsData.reduce((sum, holding) => sum + (holding.target || 0), 0);
        if (Math.abs(totalTargetPercent - 100) > 0.01) {
            alert(`Target percentages must sum to 100%. Current sum is ${totalTargetPercent.toFixed(2)}%`);
            return;
        }
        
        // Sum up all current holdings
        const totalCurrentAmount = holdingsData.reduce((sum, holding) => sum + (holding.amount || 0), 0);
        
        if (totalCurrentAmount === 0) {
            alert('Please enter current amounts for your holdings.');
            return;
        }
        
        // Calculate target amount for each holding and display the difference
        holdingsData.forEach(holding => {
            const targetAmount = (holding.target / 100) * totalCurrentAmount;
            const amountToContribute = targetAmount - (holding.amount || 0);
            
            // Update the display element
            const displayElement = document.getElementById(`calc-${holding.id}`);
            if (displayElement) {
                displayElement.textContent = amountToContribute.toFixed(2);
            }
        });
        
        // Update totals
        updateTotals();
    }

    document.getElementById('rebalance-btn').addEventListener('click', rebalance);

    // Import Holdings functionality
    const importModal = document.getElementById('import-modal');
    const importBtn = document.getElementById('import-btn');
    const closeBtn = document.querySelector('.close');
    const parseBtn = document.getElementById('parse-btn');
    const applyBtn = document.getElementById('apply-btn');
    const holdingsText = document.getElementById('holdings-text');
    const parsedResults = document.getElementById('parsed-results');
    const parsedTbody = document.getElementById('parsed-tbody');

    importBtn.addEventListener('click', () => {
        importModal.style.display = 'block';
        holdingsText.value = '';
        parsedResults.style.display = 'none';
        parsedHoldingsData = {};
    });

    closeBtn.addEventListener('click', () => {
        importModal.style.display = 'none';
    });

    window.addEventListener('click', (e) => {
        if (e.target === importModal) {
            importModal.style.display = 'none';
        }
    });

    parseBtn.addEventListener('click', () => {
        const text = holdingsText.value;
        parsedHoldingsData = parseHoldingsText(text);
        
        if (Object.keys(parsedHoldingsData).length === 0) {
            alert('No holdings found. Please check the format of your pasted data.');
            return;
        }
        
        // Display parsed results
        parsedTbody.innerHTML = '';
        Object.entries(parsedHoldingsData).forEach(([ticker, amount]) => {
            const row = document.createElement('tr');
            row.innerHTML = `
                <td><strong>${ticker}</strong></td>
                <td>$${amount.toFixed(2)}</td>
            `;
            parsedTbody.appendChild(row);
        });
        
        parsedResults.style.display = 'block';
    });

    applyBtn.addEventListener('click', () => {
        applyParsedHoldings();
        importModal.style.display = 'none';
        alert(`Successfully imported ${Object.keys(parsedHoldingsData).length} holdings!`);
    });

    function parseHoldingsText(text) {
        const holdings = {};
        const lines = text.split('\n');
        
        let currentTicker = null;
        
        for (let i = 0; i < lines.length; i++) {
            const line = lines[i].trim();
            
            // Check if line is a ticker symbol (all caps, 2-5 characters, typically alone on a line)
            // Common ticker patterns: VOO, VT, VTV, VTSAX, etc.
            if (/^[A-Z]{2,5}$/.test(line)) {
                currentTicker = line;
            }
            
            // Look for "Current position" followed by a dollar amount
            if (line.includes('Current position') && currentTicker) {
                // Look for dollar amount on this line or the next line
                let dollarMatch = line.match(/\$([0-9,]+\.\d{2})/);
                
                if (!dollarMatch && i + 1 < lines.length) {
                    // Check next line
                    dollarMatch = lines[i + 1].match(/\$([0-9,]+\.\d{2})/);
                }
                
                if (dollarMatch) {
                    const amountStr = dollarMatch[1].replace(/,/g, '');
                    const amount = parseFloat(amountStr);
                    holdings[currentTicker] = amount;
                    currentTicker = null; // Reset after finding a match
                }
            }
        }
        
        return holdings;
    }

    function applyParsedHoldings() {
        // Update existing holdings with matching tickers
        holdingsData.forEach(holding => {
            if (holding.ticker && parsedHoldingsData.hasOwnProperty(holding.ticker)) {
                holding.amount = parsedHoldingsData[holding.ticker];
                
                // Update the input field
                const amountInput = document.querySelector(`[data-field="amount"][data-row="${holding.id}"]`);
                if (amountInput) {
                    amountInput.value = parsedHoldingsData[holding.ticker].toFixed(2);
                }
            }
        });
        
        updateTotals();
    }

    initPyodide();
    
    // Prepopulate holdings
    const prepopulatedHoldings = {
        "VBIL": 2.0,
        "VSS": 29.25,
        "VCIT": 1.5,
        "VOO": 7.5,
        "VTIP": 1.5,
        "VB": 15.0,
        "VBR": 12.5,
        "VT": 15.75,
        "VTV": 15.0,
    };
    
    // Add rows for prepopulated holdings
    Object.entries(prepopulatedHoldings).forEach(([ticker, targetPercent]) => {
        addRow();
        const lastHolding = holdingsData[holdingsData.length - 1];
        const rowId = lastHolding.id;
        
        // Update the data
        lastHolding.ticker = ticker;
        lastHolding.target = targetPercent;
        lastHolding.amount = 0;
        
        // Update the input fields
        const rowElement = document.getElementById(`row-${rowId}`);
        if (rowElement) {
            rowElement.querySelector('[data-field="ticker"]').value = ticker;
            rowElement.querySelector('[data-field="target"]').value = targetPercent;
            rowElement.querySelector('[data-field="amount"]').value = 0;
        }
    });
    
    updateTotals();
</script>

</body>
</html>